;-------------------------------------------------------------------------------
include '../include/library.inc'
;-------------------------------------------------------------------------------

library 'SRLDRVCE', 0

;-------------------------------------------------------------------------------
; no dependencies
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; v0 functions (not final, subject to change!)
;-------------------------------------------------------------------------------
	export srl_Init
	export srl_SetCoding
	export srl_GetCoding
	export srl_Write
	export srl_Read
	export srl_ReadByte
	export srl_Available
	export srl_Deinit
;-------------------------------------------------------------------------------
include 'host.inc'
;-------------------------------------------------------------------------------

_dbg_Debugger:
	scf
	sbc	hl,hl
	ld	(hl),2
	ret

srl_Init:
	;call	_dbg_Debugger
	push	ix
	push	iy
	;Set up the input buffer
	ld	hl,(inputBuffer)
	ld	(bufferStart),hl
	;actual USB stuff below:
	call    usbInit				; init usb
	call    devFirst
	ld	(device),iy			; use first device
	ld	hl,xferDataPtrDefault			; get dev desc
	ld	de,reqDevDesc18
	call    setup
	ld      hl,xferDataPtrDefault+18			; get langids
	ld      de,reqGetStrDesc
	call    setup
	ld      hl,xferDataPtrDefault+18+2
	ld      de,reqGetStrDesc+4
	ldi
	ldi
	ld	iy,(device)			; get configuration descriptor
	xor     a,a
	call    getConfigDescTotalLength	; total length of config
	ld      (reqConfDesc+wLength),hl
	xor	a,a
	ld	de,xferDataPtrDefault
	adc	hl,de
	ld	(config_end),hl
	ld	iy,(device)
	ld      hl,xferDataPtrDefault
	ld      de,reqConfDesc
	call    setup
	ld	iy,(device)			; select config
	ld      ix,xferDataPtrDefault
	call	devSelectConfig
	call	useConfig
	ld	a,0
	adc	a,a
	pop	iy
	pop	ix
	ret

; Output:
;  nc = err
useConfig:
	ld	hl,xferDataPtrDefault
findCscInterface: ;credit MateoC
	ld	a,4				; interface descriptor type
	call	getDescriptor
	ret	nc
	xor	a,a
	ld	de,0
	ld	e,(iy+0)
	adc	hl,de
	ld	a,(iy+0)			; bLength
	cp	a,9
	jr	c,findCscInterface		; ensure interface length >= 9
	ld	a,(iy+5)
	cp	a,10				; bInterfaceClass == 10
	jr	nz,findCscInterface
	ld	a,(iy+2)
	;call	debugStr
	;db	'interface: ',0
	;call	debugHexA
	;call	debugNewLine
	xor	a,a
	sbc	hl,de
findEndpoints: ; credit MateoC
	push	hl
	pop	iy
	ld	b,(iy+4)
	ld	c,0
	ld	de,0
findEndpointsLoop:
	ld	a,5				; endpoint descriptor type
	call	getDescriptor
	ret	nc
	ld	a,(iy+2)
	bit	7,a
	jr	z,endpointOut
	bit	0,c
	jr	nz,endpointSkip
	ld	(ep_in),a
	;call	debugStr
	;db	'in: ',0
	;call	debugHexA
	;call	debugNewLine
	push	bc
	ld	bc,0
	ld	b,(iy+5)
	ld	c,(iy+4)
	ld	(maxPacketSize),bc
	pop	bc
	set	0,c
	jr	endpointSkip
endpointOut:
	bit	1,c
	jr	nz,endpointSkip
	ld	(ep_out),a
	;call	debugStr
	;db	'out: ',0
	;call	debugHexA
	;call	debugNewLine
	set	1,c
endpointSkip:
	;call	debugStr
	;db	'val: ',0
	;call	debugHexBC
	;call	debugNewLine
	ld	e,(iy+0)
	add	hl,de
	djnz	findEndpointsLoop
	ld	a,c
	cp	a,3
	jr	nz,endpointFail
	;call	debugStr
	;db	'valid endpoints',0
	;call	debugNewLine
	scf
	ret
endpointFail:
	scf
	ccf
	ret

;credit: MateoC
; Input:
;  hl = ptr in config
;   a = type
; Output:
;  nc = not found
;   c = found
getDescriptor:
	push	de
	push	bc
	ld	de,0
config_end := $ - 3
	ld	bc,0
findDescriptor:
	or	a,a
	sbc	hl,de
	add	hl,de
	jr	nc,notFoundDescriptor
	push	hl
	pop	iy
	ld	c,(hl)				; length of descriptor
	cp	a,(iy+1)			; bDescriptorType == 4
	jr	z,foundDescriptor
	add	hl,bc
	jr	findDescriptor
foundDescriptor:
	scf
notFoundDescriptor:
	pop	bc
	pop	de
	ret

srl_SetCoding:
	pop	de
	pop	hl
	push	hl
	push	de
	push	ix
	ld	iy,(device)
	ld	de,reqLineCoding
	call	controlDefaultTransfer
	pop	ix
	ret

srl_GetCoding:
	pop	de
	pop	hl
	push	hl
	push	de
	push	ix
	ld	iy,(device)
	ld	de,reqGetLineCoding
	push	hl
	call	controlDefaultTransfer
	call	qhRetryMaxOrAbort
	pop	hl
	pop	ix
	ret

srl_Write:
	;call	_dbg_Debugger
	pop	de
	pop	hl	; buffer
	pop	bc	; length
	push	bc
	push	hl
	push	de
	push	ix
	push	hl
	sbc	hl,hl	;check if BC is zero
	adc	hl,bc
	pop	hl
	jr	z,.skip
	push	bc
	ld	de,xferDataPtrDefault
	ldir
	ld	de,xferDataPtrDefault
	pop	bc
	ld	iy,(device)
	ld	a,0
	ep_out	:=	$-1
	call	bulkTransfer
	call	qhRetryMaxOrAbort
.skip:
	pop	ix
	ret

;this bit was generated by the C compiler. todo: optimize
srl_Read:
	;call	_dbg_Debugger
	LD	HL,-3
	CALL	__frameset
;   17		uint24_t transferred;
;   18		if(size <= bufferLen) {
	LD	BC,(IX+9)
	LD	HL,(bufferLen)
	OR	A,A
	SBC	HL,BC
	JR	C,L_3
;   19			memcpy(out, bufferStart, size);
	LD	BC,(IX+9)
	LD	hl,(bufferStart)
	LD	de,(IX+6)
	push	hl
	sbc hl,hl ;check if BC is zero
    adc hl,bc
    pop	hl
    jr z,.skip
	ldir
;   20			bufferStart += size;
	LD	BC,(IX+9)
	LD	HL,(bufferStart)
	ADD	HL,BC
	LD	(bufferStart),HL
;   21			bufferLen -= size;
	LD	HL,(bufferLen)
	LD	BC,(IX+9)
	OR	A,A
	SBC	HL,BC
	LD	(bufferLen),HL
;   22			return size;
.skip:
	LD	HL,(IX+9)
	JR	L_4
;   23		}
;   24		else {
L_3:
;   25			memcpy(out, bufferStart, bufferLen);
	LD	BC,(bufferLen)
	sbc hl,hl ;check if BC is zero
    adc hl,bc
    jr	z,.skip
	LD	hl,(bufferStart)
	LD	de,(IX+6)
	ldir
.skip:
;   26			transferred = bufferLen;
	LD	BC,(bufferLen)
	LD	(IX+-3),BC
;   27			bufferLen = 0;
	LD	BC,0
;   28			bufferStart = serialBuffer;
;   29			bufferLen = receive(serialBuffer);
	LD	DE,inputBuffer
	PUSH	DE
	LD	(bufferLen),BC
	LD	BC,inputBuffer
	LD	(bufferStart),BC
	CALL	_receive
	POP	BC
;   30			if(!bufferLen)
	CALL	__icmpzero
	LD	(bufferLen),HL
	JR	NZ,L_1
;   31				return transferred;
	LD	HL,(IX+-3)
	JR	L_4
L_1:
;   32			return srl_Read(out + transferred, size - transferred);
	LD	BC,(IX+-3)
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	srl_Read
	POP	BC
	POP	BC
;   33		}
;   34	}
L_4:
	LD	SP,IX
	POP	IX
	RET

srl_ReadByte:
	call	srl_Available
	or	a,a
	jr	z, srl_ReadByte
	ld	bc, 1
	push	bc
	ld	bc, .byte
	push	bc
	call	srl_Read
	pop	bc
	pop	bc
	ld	a, 0
	.byte	:= $ - 1
	ret

srl_Available:
	ld	hl,(bufferLen)
	call	__icmpzero
	jr	z,.zero
	ld	a,1
	ret
.zero:
	ld	bc,inputBuffer
	push	bc
	ld	(bufferStart),bc
	call	_receive
	pop	bc
	ld	(bufferLen),hl
	ld	bc,(bufferLen)
	xor	a,a
	sbc	hl,hl
	sbc	hl, bc
	adc	a,0
	ret

srl_Deinit:
	push	ix
	push	iy
	call	usbCleanup
	pop	iy
	pop	ix
	ret

_receive:
	pop	hl
	pop	de ; buffer
	push	de
	push	hl
	push	ix
	ld	iy,(device)
	ld	a,0
	ep_in := $-1
	ld	bc,64
	maxPacketSize := $-3
	call	bulkTransfer
	ld	b,0
	call	qhRetry
	xor	a,a
	ld	hl,(maxPacketSize)
	sbc	hl,bc
	pop	ix
	ret

; Input:
;  de = req
;  hl = buf
setup:
	ld	iy,0
	device := $ - 3
	call    controlDefaultTransfer
	jp      qhRetryMaxOrAbort

reqTypeSetLnCoding	:= $20
reqTypeGetLnCoding	:= $21

reqDevDesc18:
	db	$80,reqTypeGetDesc,0,descTypeDev,0,0,18,0
reqConfDesc:
	db	$80,reqTypeGetDesc,0,descTypeConf,0,0,0,0
reqGetStrDesc:
	db	$80,reqTypeGetDesc,0,descTypeStr,0,0,0,1,0
lineCodingLen	:= 7
reqLineCoding:
	db	$21,reqTypeSetLnCoding,0,0,0,0,lineCodingLen,0
reqGetLineCoding:
	db	$A1,reqTypeGetLnCoding,0,0,0,0,lineCodingLen,0
lineCoding:
	db	$80,$25,0,0,0,0,8

;db 0 ; alignment

xferDataPtrDefault:
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

bufferStart:
	db	0,0,0
bufferLen:
	db	0,0,0

inputBuffer:
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

